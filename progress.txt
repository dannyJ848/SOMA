# Biological Self - Progress & Learnings

## Completed Work

### Phase 0: Foundation (COMPLETE)
- [x] Encrypted SQLite data store with AES-256-GCM
- [x] Core health data types (conditions, meds, allergies, surgeries, family history, labs, vitals, imaging)
- [x] Lab results importer with LLM extraction
- [x] Pharmacogenomics data model (gene variants, phenotypes, drug guidance)
- [x] Neuropsychological evaluations with longitudinal tracking
- [x] Imaging reports importer (CT scans)
- [x] Whoop wearable integration (cycles + workouts)
- [x] Apple Health integration (daily summaries + workouts)

### Data Imported
- 75 lab results from Whoop Labs PDFs
- 24 pharmacogenomic genes + 30 drug guidance from Quest Diagnostics
- 3 neuropsych evaluations (2018, 2019, 2025) showing longitudinal cognitive changes
- 4 CT imaging reports (SBO history 2017-2021)
- 255 Whoop cycles + 247 Whoop workouts (Apr-Dec 2025)
- 891 Apple Health daily summaries + 647 workouts (2019-2026)

## Key Learnings

### 1. Date Handling Critical
Always deserialize dates from JSON. Forgetting this causes subtle bugs where date comparisons fail.

### 2. Duplicate Detection Pattern
Before importing, always check for existing records using a unique identifier (date + type, or specific ID).

### 3. Large File Streaming
For 100MB+ files (Apple Health XML), use streaming parsers not in-memory loading.

### 4. Store Pattern
After calling store.addX(), call store.get() again to refresh the self object.

### 5. Passphrase from Environment
Use BIOSELF_PASSPHRASE environment variable for non-interactive scripts.

## Codebase Patterns

- **IPC Bridge Pattern**: Tauri Rust commands call TypeScript via `npx tsx tauri-bridge.ts <command>` with env vars for passphrase and db path
- **React Frontend**: All UI in `src/` directory, Vite builds to `dist/`
- **Tauri Config**: Main config in `src-tauri/tauri.conf.json`, capabilities in `src-tauri/capabilities/`
- **Run Dev**: Use `npm run tauri:dev` to start both Vite and Tauri
- **TypeScript Check**: Run `npm run typecheck` before committing

---

## 2026-01-20 - US-009

### What was implemented
- Tauri 2.x desktop app shell with React frontend
- Vite build configuration for development and production
- IPC bridge script (`tauri-bridge.ts`) connecting Rust commands to TypeScript database layer
- React app with authentication flow and dashboard showing health data counts
- Dark theme UI with responsive design
- Window chrome configuration (1024x768, centered, resizable)

### Files changed
- **New**: `src-tauri/` - Rust backend with IPC commands
- **New**: `src/` - React frontend (App.tsx, main.tsx, styles.css)
- **New**: `tauri-bridge.ts` - TypeScript CLI for Tauri IPC
- **New**: `vite.config.ts` - Vite configuration
- **New**: `index.html` - Vite entry point
- **New**: `public/icon.svg` - App icon
- **Modified**: `package.json` - Added Tauri/Vite scripts and dependencies
- **Modified**: `tsconfig.json` - Updated for React/JSX support
- **Modified**: Various files to fix unused import/variable TypeScript errors

### Learnings for future iterations
- Tauri 2.x requires the shell plugin for running external commands
- First Rust build takes several minutes (compiling 400+ crates)
- The bridge pattern (Rust -> TypeScript via CLI) works well for keeping existing database code
- Capabilities must be configured in `src-tauri/capabilities/default.json` for shell access
- CSP must allow `style-src 'unsafe-inline'` for React inline styles

---

## 2026-01-20 - US-010

### What was implemented
- Enhanced first-run experience with comprehensive privacy explanation
- Passphrase creation with confirmation field for new databases
- Password strength indicator (Too short → Weak → Good → Strong)
- Three privacy feature cards explaining encryption, local-only storage, and user control
- Improved unlock flow for existing databases
- Error handling with clear messages and "Clear and try again" option
- Loading states during submit operations

### Files changed
- **Modified**: `src/App.tsx` - Complete auth flow overhaul
- **Modified**: `src/styles.css` - New styles for auth components

### Learnings for future iterations
- Keep auth flow separate from dashboard - makes state management cleaner
- Passphrase strength should guide users but not block (8 char minimum is enforced)
- Error messages should be actionable - include retry mechanism
- Privacy messaging is important for user trust in a health app

---

## 2026-01-20 - US-011

### What was implemented
- Extended tauri-bridge.ts with `get-dashboard` command returning full health data
- Added Rust structs for dashboard data types (ConditionSummary, MedicationSummary, LabWithTrend, VitalsSummary)
- Implemented session passphrase storage in Rust for subsequent IPC calls
- Created comprehensive dashboard with four main sections:
  - Vitals Summary: resting HR, HRV, recovery score, sleep hours, steps
  - Active Conditions: list with status badges (active/chronic)
  - Current Medications: list with dosage and frequency
  - Recent Labs: grid with values, units, and trend indicators
- Lab trend calculation uses 5% threshold to determine up/down/stable
- Empty states with contextual icons for all sections
- Data summary footer with total counts

### Files changed
- **Modified**: `tauri-bridge.ts` - Added get-dashboard command with trend calculation
- **Modified**: `src-tauri/src/lib.rs` - Added DashboardData structs and get_dashboard command
- **Modified**: `src/App.tsx` - Full dashboard implementation with cards
- **Modified**: `src/styles.css` - Dashboard styles (grids, cards, badges, trends)

### Learnings for future iterations
- Store passphrase in Rust static for session persistence (avoids re-auth on each call)
- Trend calculation needs threshold to avoid noise (5% works well)
- serde_json::Value useful for polymorphic fields (lab values can be number or string)
- Grid layouts with auto-fit work well for responsive card layouts

---

## 2026-01-20 - US-012

### What was implemented
- Timeline data aggregation in tauri-bridge.ts collecting events from labs, imaging, conditions, medications, surgeries
- New `get-timeline` Rust command with optional filter parameters (types, startDate, endDate)
- Timeline React component with vertical layout and color-coded event markers
- Six event type colors: lab=blue, imaging=purple, condition=amber, medication=emerald, surgery=red, symptom=orange
- Filter toggles allowing users to show/hide event types
- Date range selector with clear button
- Click-to-detail modal showing full event information
- Navigation between dashboard and timeline views

### Files changed
- **Modified**: `tauri-bridge.ts` - Added TimelineEvent/TimelineData interfaces, getTimelineEvents, getTimelineData functions, and get-timeline command
- **Modified**: `src-tauri/src/lib.rs` - Added TimelineEvent, TimelineFilters, TimelineData structs and get_timeline command
- **Modified**: `src/App.tsx` - Added Timeline view, filters, date range selector, event detail modal, navigation
- **Modified**: `src/styles.css` - Added timeline styles (controls, items, markers, modal)

### Learnings for future iterations
- Rust command parameters should be Optional types for clean API design
- CSS timeline with ::before pseudo-element for the vertical line works well
- Modal pattern: overlay onClick closes, content stopPropagation prevents close
- Event color mapping with Record<Type, string> provides type safety
- useEffect dependencies should include filter state for auto-reload on filter change

---

## 2026-01-20 - US-013

### What was implemented
- Symptom interface with comprehensive fields: description, severity (1-10 literal type), bodyLocation (hierarchical string), onsetDate, duration, resolvedDate, status, associatedFactors, quality, frequency, timeOfDay, notes
- SymptomDuration interface for tracking duration with value and unit (minutes/hours/days/weeks/months/ongoing)
- AssociatedFactor type with 14 predefined values (after-eating, with-exertion, at-rest, etc.)
- SymptomQuality type with 15 predefined descriptors (sharp, dull, aching, burning, etc.)
- Store CRUD methods: addSymptom, updateSymptom, removeSymptom, resolveSymptom
- Store query methods: getActiveSymptoms, getSymptomsByLocation (with prefix matching), getSymptomsByDateRange
- Deserialize handles symptom dates (onsetDate, resolvedDate, createdAt, updatedAt)
- Search method includes symptoms (searches description, bodyLocation, notes)

### Files changed
- **Modified**: `core/biological-self/types.ts` - Added Symptom, SymptomDuration, AssociatedFactor, SymptomQuality types; added symptoms[] to BiologicalSelf
- **Modified**: `core/biological-self/store.ts` - Added Symptom import, symptoms array init, CRUD methods, query methods, deserialize, search

### Learnings for future iterations
- Use literal union types (1 | 2 | ... | 10) for bounded numeric values
- Prefix matching on hierarchical location codes enables flexible queries (e.g., "body.torso" matches all torso symptoms)
- Type aliases (AssociatedFactor, SymptomQuality) document valid values while being lightweight
- Include || [] fallback in deserialize for backwards compatibility with existing data

---

## 2026-01-20 - US-014

### What was implemented
- BodyDiagram.tsx component with SVG-based body outline
- Anterior (front) view with 26 body regions (head, neck, torso, arms, legs)
- Posterior (back) view with 24 body regions
- Toggle buttons to switch between anterior/posterior views
- Hover effect highlights region with tooltip showing region name
- Click-to-select functionality with visual selection state
- Symptom markers displayed on regions with existing symptoms
- Body Map view integrated into main app navigation
- Selected region ID available for passing to symptom entry form (US-015)
- Hierarchical body location codes (e.g., body.torso.abdomen.right-lower-quadrant)
- Helper functions: getRegionName(), getAllRegions()

### Files changed
- **New**: `src/BodyDiagram.tsx` - SVG body diagram component with regions and interaction
- **Modified**: `src/App.tsx` - Added body view, body diagram state, navigation
- **Modified**: `src/styles.css` - Added body diagram styles (regions, tooltips, markers, controls)

### Learnings for future iterations
- SVG paths for body regions can be simplified polygons, doesn't need perfect anatomy
- Tooltip positioning needs transform: translateX(-50%) for centering
- Use data-location attribute pattern for associating regions with hierarchical codes
- Symptom markers use prefix matching to find parent regions
- Keep anterior/posterior regions in separate arrays for clean view switching

---

## 2026-01-20 - US-015

### What was implemented
- Add-symptom command in tauri-bridge.ts receiving JSON data as argument
- Rust add_symptom command with SymptomInput struct for type-safe deserialization
- SymptomEntryForm React component with comprehensive form fields:
  - Body location dropdown (pre-selected from diagram via getAllRegions helper)
  - Symptom description textarea
  - Severity slider (1-10) with descriptive labels (Minimal→Worst possible)
  - Date/time picker for onset using datetime-local input
  - Duration toggle (ongoing vs specific with value + unit)
  - Associated factors checkboxes (13 predefined values from types.ts)
  - Additional notes textarea
- Integration into Body Map view with form state management
- Dashboard recentSymptoms now populated from actual symptom data
- Timeline view includes symptoms as orange event markers
- Form validation (description and body location required)
- Save/cancel flow with dashboard refresh on successful save

### Files changed
- **Modified**: `tauri-bridge.ts` - Added add-symptom case, getRecentSymptoms function, symptoms in timeline events
- **Modified**: `src-tauri/src/lib.rs` - Added SymptomInput, SymptomDuration, AddSymptomResult structs and add_symptom command
- **New**: `src/SymptomEntryForm.tsx` - Complete symptom entry form component
- **Modified**: `src/App.tsx` - Added showSymptomForm state, integrated SymptomEntryForm in body view
- **Modified**: `src/styles.css` - Added 288 lines of form styles (slider, checkboxes, duration controls)

### Learnings for future iterations
- Pass complex data to tauri-bridge via JSON string argument (process.argv[3])
- Use serde rename attributes for camelCase→snake_case field mapping in Rust
- getAllRegions() helper from BodyDiagram.tsx provides sorted, deduplicated list
- Symptom severity as literal type (1|2|...|10) requires casting when passing to invoke
- Duration "ongoing" is stored as {value: 0, unit: "ongoing"} rather than undefined
- Form components should call parent callbacks (onSave/onCancel) rather than managing navigation

---

---

## 2026-01-20 - US-016

### What was implemented
- Ollama service module (core/ai/ollama.ts) with comprehensive TypeScript interface
- Functions: checkOllamaHealth, isOllamaAvailable, listModels, hasModel, getDefaultModel
- Chat completion: chat (non-streaming), streamChat (callback-based), streamChatGenerator (async iterator)
- JSON mode: chatJSON<T> for structured output parsing
- AI bridge CLI (ai-bridge.ts) for Tauri IPC commands: health, models, chat, chat-json, stream
- Rust Tauri commands: ai_health, ai_models, ai_chat, ai_chat_json
- Type definitions: OllamaModel, ChatMessage, ChatRequest, ChatResponse, StreamChunk, OllamaStatus

### Files changed
- **New**: `core/ai/ollama.ts` - Full Ollama service implementation (437 lines)
- **New**: `ai-bridge.ts` - CLI for Tauri AI IPC (181 lines)
- **Modified**: `src-tauri/src/lib.rs` - Added AI types and commands
- **Modified**: `prd.json` - US-016 passes: true

### Learnings for future iterations
- **AI Bridge Pattern**: Same pattern as tauri-bridge.ts but for AI operations via ai-bridge.ts
- Default model is deepseek-r1:14b (configurable via DEFAULT_MODEL constant)
- Ollama REST API at http://localhost:11434 - use /api/version for health, /api/tags for models, /api/chat for completion
- Streaming responses are NDJSON format, process line-by-line
- AbortSignal.timeout() provides clean timeout handling for fetch requests
- For JSON mode, pass format: 'json' in request body

---

## 2026-01-20 - US-017

### What was implemented
- ChatView React component with full conversational interface
- Health context builder (buildHealthContext) extracts relevant health data for AI prompts
- System prompt template with educational guidelines and medical disclaimer
- Ollama health check on component mount with retry capability
- Suggested questions for empty chat state
- User/assistant message styling with avatars
- Typing indicator during AI response
- Chat navigation button in dashboard header

### Files changed
- **New**: `src/ChatView.tsx` - Complete chat interface component (280 lines)
- **Modified**: `src/App.tsx` - Added chat view rendering and navigation
- **Modified**: `src/styles.css` - Added 330 lines of chat-specific styles
- **Modified**: `prd.json` - US-017 passes: true

### Learnings for future iterations
- Health context should be concise - only include active conditions, current meds, recent symptoms, abnormal labs
- System prompt template with placeholder (`{HEALTH_CONTEXT}`) allows dynamic context injection
- AI status check on mount catches Ollama not running before user tries to chat
- Suggested questions help users understand what they can ask
- Use `white-space: pre-wrap` on message content to preserve AI formatting

---

## Next Up

US-018: Natural language symptom entry (Phase 2)

## Notes for Future Iterations

- The user is a medical student, so clinical accuracy matters
- Vision includes Complete Anatomy-level 3D interface
- All data must stay local - this is the core differentiator
- Educational only, never diagnostic

