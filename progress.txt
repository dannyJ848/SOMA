# Biological Self - Progress & Learnings

## Completed Work

### Phase 0: Foundation (COMPLETE)
- [x] Encrypted SQLite data store with AES-256-GCM
- [x] Core health data types (conditions, meds, allergies, surgeries, family history, labs, vitals, imaging)
- [x] Lab results importer with LLM extraction
- [x] Pharmacogenomics data model (gene variants, phenotypes, drug guidance)
- [x] Neuropsychological evaluations with longitudinal tracking
- [x] Imaging reports importer (CT scans)
- [x] Whoop wearable integration (cycles + workouts)
- [x] Apple Health integration (daily summaries + workouts)

### Data Imported
- 75 lab results from Whoop Labs PDFs
- 24 pharmacogenomic genes + 30 drug guidance from Quest Diagnostics
- 3 neuropsych evaluations (2018, 2019, 2025) showing longitudinal cognitive changes
- 4 CT imaging reports (SBO history 2017-2021)
- 255 Whoop cycles + 247 Whoop workouts (Apr-Dec 2025)
- 891 Apple Health daily summaries + 647 workouts (2019-2026)

## Key Learnings

### 1. Date Handling Critical
Always deserialize dates from JSON. Forgetting this causes subtle bugs where date comparisons fail.

### 2. Duplicate Detection Pattern
Before importing, always check for existing records using a unique identifier (date + type, or specific ID).

### 3. Large File Streaming
For 100MB+ files (Apple Health XML), use streaming parsers not in-memory loading.

### 4. Store Pattern
After calling store.addX(), call store.get() again to refresh the self object.

### 5. Passphrase from Environment
Use BIOSELF_PASSPHRASE environment variable for non-interactive scripts.

## Codebase Patterns

- **IPC Bridge Pattern**: Tauri Rust commands call TypeScript via `npx tsx tauri-bridge.ts <command>` with env vars for passphrase and db path
- **React Frontend**: All UI in `src/` directory, Vite builds to `dist/`
- **Tauri Config**: Main config in `src-tauri/tauri.conf.json`, capabilities in `src-tauri/capabilities/`
- **Run Dev**: Use `npm run tauri:dev` to start both Vite and Tauri
- **TypeScript Check**: Run `npm run typecheck` before committing

---

## 2026-01-20 - US-009

### What was implemented
- Tauri 2.x desktop app shell with React frontend
- Vite build configuration for development and production
- IPC bridge script (`tauri-bridge.ts`) connecting Rust commands to TypeScript database layer
- React app with authentication flow and dashboard showing health data counts
- Dark theme UI with responsive design
- Window chrome configuration (1024x768, centered, resizable)

### Files changed
- **New**: `src-tauri/` - Rust backend with IPC commands
- **New**: `src/` - React frontend (App.tsx, main.tsx, styles.css)
- **New**: `tauri-bridge.ts` - TypeScript CLI for Tauri IPC
- **New**: `vite.config.ts` - Vite configuration
- **New**: `index.html` - Vite entry point
- **New**: `public/icon.svg` - App icon
- **Modified**: `package.json` - Added Tauri/Vite scripts and dependencies
- **Modified**: `tsconfig.json` - Updated for React/JSX support
- **Modified**: Various files to fix unused import/variable TypeScript errors

### Learnings for future iterations
- Tauri 2.x requires the shell plugin for running external commands
- First Rust build takes several minutes (compiling 400+ crates)
- The bridge pattern (Rust -> TypeScript via CLI) works well for keeping existing database code
- Capabilities must be configured in `src-tauri/capabilities/default.json` for shell access
- CSP must allow `style-src 'unsafe-inline'` for React inline styles

---

## 2026-01-20 - US-010

### What was implemented
- Enhanced first-run experience with comprehensive privacy explanation
- Passphrase creation with confirmation field for new databases
- Password strength indicator (Too short → Weak → Good → Strong)
- Three privacy feature cards explaining encryption, local-only storage, and user control
- Improved unlock flow for existing databases
- Error handling with clear messages and "Clear and try again" option
- Loading states during submit operations

### Files changed
- **Modified**: `src/App.tsx` - Complete auth flow overhaul
- **Modified**: `src/styles.css` - New styles for auth components

### Learnings for future iterations
- Keep auth flow separate from dashboard - makes state management cleaner
- Passphrase strength should guide users but not block (8 char minimum is enforced)
- Error messages should be actionable - include retry mechanism
- Privacy messaging is important for user trust in a health app

---

## 2026-01-20 - US-011

### What was implemented
- Extended tauri-bridge.ts with `get-dashboard` command returning full health data
- Added Rust structs for dashboard data types (ConditionSummary, MedicationSummary, LabWithTrend, VitalsSummary)
- Implemented session passphrase storage in Rust for subsequent IPC calls
- Created comprehensive dashboard with four main sections:
  - Vitals Summary: resting HR, HRV, recovery score, sleep hours, steps
  - Active Conditions: list with status badges (active/chronic)
  - Current Medications: list with dosage and frequency
  - Recent Labs: grid with values, units, and trend indicators
- Lab trend calculation uses 5% threshold to determine up/down/stable
- Empty states with contextual icons for all sections
- Data summary footer with total counts

### Files changed
- **Modified**: `tauri-bridge.ts` - Added get-dashboard command with trend calculation
- **Modified**: `src-tauri/src/lib.rs` - Added DashboardData structs and get_dashboard command
- **Modified**: `src/App.tsx` - Full dashboard implementation with cards
- **Modified**: `src/styles.css` - Dashboard styles (grids, cards, badges, trends)

### Learnings for future iterations
- Store passphrase in Rust static for session persistence (avoids re-auth on each call)
- Trend calculation needs threshold to avoid noise (5% works well)
- serde_json::Value useful for polymorphic fields (lab values can be number or string)
- Grid layouts with auto-fit work well for responsive card layouts

---

## 2026-01-20 - US-012

### What was implemented
- Timeline data aggregation in tauri-bridge.ts collecting events from labs, imaging, conditions, medications, surgeries
- New `get-timeline` Rust command with optional filter parameters (types, startDate, endDate)
- Timeline React component with vertical layout and color-coded event markers
- Six event type colors: lab=blue, imaging=purple, condition=amber, medication=emerald, surgery=red, symptom=orange
- Filter toggles allowing users to show/hide event types
- Date range selector with clear button
- Click-to-detail modal showing full event information
- Navigation between dashboard and timeline views

### Files changed
- **Modified**: `tauri-bridge.ts` - Added TimelineEvent/TimelineData interfaces, getTimelineEvents, getTimelineData functions, and get-timeline command
- **Modified**: `src-tauri/src/lib.rs` - Added TimelineEvent, TimelineFilters, TimelineData structs and get_timeline command
- **Modified**: `src/App.tsx` - Added Timeline view, filters, date range selector, event detail modal, navigation
- **Modified**: `src/styles.css` - Added timeline styles (controls, items, markers, modal)

### Learnings for future iterations
- Rust command parameters should be Optional types for clean API design
- CSS timeline with ::before pseudo-element for the vertical line works well
- Modal pattern: overlay onClick closes, content stopPropagation prevents close
- Event color mapping with Record<Type, string> provides type safety
- useEffect dependencies should include filter state for auto-reload on filter change

---

## 2026-01-20 - US-013

### What was implemented
- Symptom interface with comprehensive fields: description, severity (1-10 literal type), bodyLocation (hierarchical string), onsetDate, duration, resolvedDate, status, associatedFactors, quality, frequency, timeOfDay, notes
- SymptomDuration interface for tracking duration with value and unit (minutes/hours/days/weeks/months/ongoing)
- AssociatedFactor type with 14 predefined values (after-eating, with-exertion, at-rest, etc.)
- SymptomQuality type with 15 predefined descriptors (sharp, dull, aching, burning, etc.)
- Store CRUD methods: addSymptom, updateSymptom, removeSymptom, resolveSymptom
- Store query methods: getActiveSymptoms, getSymptomsByLocation (with prefix matching), getSymptomsByDateRange
- Deserialize handles symptom dates (onsetDate, resolvedDate, createdAt, updatedAt)
- Search method includes symptoms (searches description, bodyLocation, notes)

### Files changed
- **Modified**: `core/biological-self/types.ts` - Added Symptom, SymptomDuration, AssociatedFactor, SymptomQuality types; added symptoms[] to BiologicalSelf
- **Modified**: `core/biological-self/store.ts` - Added Symptom import, symptoms array init, CRUD methods, query methods, deserialize, search

### Learnings for future iterations
- Use literal union types (1 | 2 | ... | 10) for bounded numeric values
- Prefix matching on hierarchical location codes enables flexible queries (e.g., "body.torso" matches all torso symptoms)
- Type aliases (AssociatedFactor, SymptomQuality) document valid values while being lightweight
- Include || [] fallback in deserialize for backwards compatibility with existing data

---

## 2026-01-20 - US-014

### What was implemented
- BodyDiagram.tsx component with SVG-based body outline
- Anterior (front) view with 26 body regions (head, neck, torso, arms, legs)
- Posterior (back) view with 24 body regions
- Toggle buttons to switch between anterior/posterior views
- Hover effect highlights region with tooltip showing region name
- Click-to-select functionality with visual selection state
- Symptom markers displayed on regions with existing symptoms
- Body Map view integrated into main app navigation
- Selected region ID available for passing to symptom entry form (US-015)
- Hierarchical body location codes (e.g., body.torso.abdomen.right-lower-quadrant)
- Helper functions: getRegionName(), getAllRegions()

### Files changed
- **New**: `src/BodyDiagram.tsx` - SVG body diagram component with regions and interaction
- **Modified**: `src/App.tsx` - Added body view, body diagram state, navigation
- **Modified**: `src/styles.css` - Added body diagram styles (regions, tooltips, markers, controls)

### Learnings for future iterations
- SVG paths for body regions can be simplified polygons, doesn't need perfect anatomy
- Tooltip positioning needs transform: translateX(-50%) for centering
- Use data-location attribute pattern for associating regions with hierarchical codes
- Symptom markers use prefix matching to find parent regions
- Keep anterior/posterior regions in separate arrays for clean view switching

---

## 2026-01-20 - US-015

### What was implemented
- Add-symptom command in tauri-bridge.ts receiving JSON data as argument
- Rust add_symptom command with SymptomInput struct for type-safe deserialization
- SymptomEntryForm React component with comprehensive form fields:
  - Body location dropdown (pre-selected from diagram via getAllRegions helper)
  - Symptom description textarea
  - Severity slider (1-10) with descriptive labels (Minimal→Worst possible)
  - Date/time picker for onset using datetime-local input
  - Duration toggle (ongoing vs specific with value + unit)
  - Associated factors checkboxes (13 predefined values from types.ts)
  - Additional notes textarea
- Integration into Body Map view with form state management
- Dashboard recentSymptoms now populated from actual symptom data
- Timeline view includes symptoms as orange event markers
- Form validation (description and body location required)
- Save/cancel flow with dashboard refresh on successful save

### Files changed
- **Modified**: `tauri-bridge.ts` - Added add-symptom case, getRecentSymptoms function, symptoms in timeline events
- **Modified**: `src-tauri/src/lib.rs` - Added SymptomInput, SymptomDuration, AddSymptomResult structs and add_symptom command
- **New**: `src/SymptomEntryForm.tsx` - Complete symptom entry form component
- **Modified**: `src/App.tsx` - Added showSymptomForm state, integrated SymptomEntryForm in body view
- **Modified**: `src/styles.css` - Added 288 lines of form styles (slider, checkboxes, duration controls)

### Learnings for future iterations
- Pass complex data to tauri-bridge via JSON string argument (process.argv[3])
- Use serde rename attributes for camelCase→snake_case field mapping in Rust
- getAllRegions() helper from BodyDiagram.tsx provides sorted, deduplicated list
- Symptom severity as literal type (1|2|...|10) requires casting when passing to invoke
- Duration "ongoing" is stored as {value: 0, unit: "ongoing"} rather than undefined
- Form components should call parent callbacks (onSave/onCancel) rather than managing navigation

---

---

## 2026-01-20 - US-016

### What was implemented
- Ollama service module (core/ai/ollama.ts) with comprehensive TypeScript interface
- Functions: checkOllamaHealth, isOllamaAvailable, listModels, hasModel, getDefaultModel
- Chat completion: chat (non-streaming), streamChat (callback-based), streamChatGenerator (async iterator)
- JSON mode: chatJSON<T> for structured output parsing
- AI bridge CLI (ai-bridge.ts) for Tauri IPC commands: health, models, chat, chat-json, stream
- Rust Tauri commands: ai_health, ai_models, ai_chat, ai_chat_json
- Type definitions: OllamaModel, ChatMessage, ChatRequest, ChatResponse, StreamChunk, OllamaStatus

### Files changed
- **New**: `core/ai/ollama.ts` - Full Ollama service implementation (437 lines)
- **New**: `ai-bridge.ts` - CLI for Tauri AI IPC (181 lines)
- **Modified**: `src-tauri/src/lib.rs` - Added AI types and commands
- **Modified**: `prd.json` - US-016 passes: true

### Learnings for future iterations
- **AI Bridge Pattern**: Same pattern as tauri-bridge.ts but for AI operations via ai-bridge.ts
- Default model is deepseek-r1:14b (configurable via DEFAULT_MODEL constant)
- Ollama REST API at http://localhost:11434 - use /api/version for health, /api/tags for models, /api/chat for completion
- Streaming responses are NDJSON format, process line-by-line
- AbortSignal.timeout() provides clean timeout handling for fetch requests
- For JSON mode, pass format: 'json' in request body

---

## 2026-01-20 - US-017

### What was implemented
- ChatView React component with full conversational interface
- Health context builder (buildHealthContext) extracts relevant health data for AI prompts
- System prompt template with educational guidelines and medical disclaimer
- Ollama health check on component mount with retry capability
- Suggested questions for empty chat state
- User/assistant message styling with avatars
- Typing indicator during AI response
- Chat navigation button in dashboard header

### Files changed
- **New**: `src/ChatView.tsx` - Complete chat interface component (280 lines)
- **Modified**: `src/App.tsx` - Added chat view rendering and navigation
- **Modified**: `src/styles.css` - Added 330 lines of chat-specific styles
- **Modified**: `prd.json` - US-017 passes: true

### Learnings for future iterations
- Health context should be concise - only include active conditions, current meds, recent symptoms, abnormal labs
- System prompt template with placeholder (`{HEALTH_CONTEXT}`) allows dynamic context injection
- AI status check on mount catches Ollama not running before user tries to chat
- Suggested questions help users understand what they can ask
- Use `white-space: pre-wrap` on message content to preserve AI formatting

---

## 2026-01-20 - US-018

### What was implemented
- Two-mode SymptomEntryForm: NL input mode and manual form mode
- NL input mode with textarea for natural language description
- AI parsing using JSON mode with structured output prompt
- Body location mapping (BODY_LOCATION_MAP) from common terms to hierarchical codes
- Form pre-fill with parsed data (description, severity, location, duration, factors)
- "Parse with AI" button with loading spinner
- "Fill form manually instead" fallback option
- "Describe naturally" button in manual mode header to switch back
- AI availability check on mount with warning message

### Files changed
- **Modified**: `src/SymptomEntryForm.tsx` - Added NL mode, parsing function, body location mapping (200+ lines)
- **Modified**: `src/styles.css` - Added NL input styles (150+ lines)
- **Modified**: `prd.json` - US-018 passes: true

### Learnings for future iterations
- Body location mapping handles common synonyms (stomach→abdomen, belly→abdomen)
- Use low temperature (0.3) for structured data extraction to reduce hallucination
- Fallback to manual mode when AI unavailable - don't block the user
- Preselected region from body diagram should skip NL mode (already have location)
- JSON mode response comes as `{ result: T, success: boolean }`

---

## 2026-01-20 - US-019

### What was implemented
- InsightsPanel component with AI-powered health data analysis
- buildDataSummary function extracts relevant health data for AI prompts
- System prompt instructs AI to generate 2-4 objective insights as JSON array
- Skeleton loading animation while generating insights
- Refresh button to regenerate insights on demand
- dataVersion prop triggers insights refresh when dashboard data changes
- Educational disclaimer in panel header
- Panel hides itself when AI is unavailable

### Files changed
- **New**: `src/InsightsPanel.tsx` - Complete insights panel component (200 lines)
- **Modified**: `src/App.tsx` - Added InsightsPanel import and dataVersion state
- **Modified**: `src/styles.css` - Added 150+ lines of insights panel styles
- **Modified**: `prd.json` - US-019 passes: true

### Learnings for future iterations
- Use JSON array output for structured insights (easier to parse and display)
- dataVersion pattern allows parent to signal data changes to children
- Skeleton loading animation (shimmer effect) provides good UX during AI generation
- Hide components gracefully when dependencies unavailable rather than showing errors
- Focus AI prompts on patterns and correlations, not diagnoses

---

## Phase 2 Complete

All AI layer user stories implemented:
- US-016: Local LLM integration with Ollama
- US-017: AI chat interface
- US-018: Natural language symptom entry
- US-019: Health insights panel

---

## 2026-01-20 - Phase 3 PRD Created

### What was implemented
- Comprehensive Phase 3 PRD with 53 user stories (US-020 to US-072)
- phase3-draft.md planning document with technical architecture

### Phase 3 Structure (7 sub-phases)
- **3A: 3D Foundation** (US-020–027): Three.js, camera, Z-Anatomy, VHP cadaver, layers, selection, clipping
- **3B: Content System** (US-028–029): 5-tier complexity levels, multi-level data model
- **3C: Knowledge Infrastructure** (US-030–041): ChromaDB, embeddings, OpenStax, StatPearls, histology, FMA/HPO, RAG
- **3D: Anatomical Systems** (US-042–053): All 11 body systems with 5-level educational content
- **3E: Biomarker Integration** (US-054–059): Lab-to-organ mapping, pathway visualization
- **3F: Symptom Integration** (US-060–065): Symptom-to-anatomy, differentials, referral patterns
- **3G: Personalized Learning** (US-066–072): Progress tracking, quizzes, AI cueing

### Key Decisions Made
1. Full detail from start - no progressive loading (~10-18GB storage)
2. Include VHP cadaver cross-sections
3. Include complete histology database
4. 5 complexity levels: 8th grade → high school → college → graduate → MD
5. Extensive symptom ↔ biomarker ↔ anatomy linking
6. Precise AI cueing for proactive education

### Files changed
- **Modified**: `prd.json` - Added 53 Phase 3 user stories
- **New**: `phase3-draft.md` - Comprehensive planning document (870 lines)

### Learnings for future iterations
- Z-Anatomy (CC-BY-SA) provides complete 3D anatomy models
- Visible Human Project is public domain (NIH)
- OpenStax A&P and StatPearls are CC-BY - perfect for RAG
- FMA ontology (~80k terms) critical for structure linking
- HPO ontology links symptoms to anatomical locations
- @xenova/transformers enables browser-compatible local embeddings
- OpenSeadragon handles deep zoom for histology images

---

## 2026-01-20 - US-020

### What was implemented
- AnatomyViewer React component using @react-three/fiber
- WebGL2 renderer with antialiasing and dpr scaling [1, 2]
- Three-point lighting system (ambient + 2 directional lights)
- Perspective camera at 45° FOV
- OrbitControls with damping for smooth interaction
- Preset anatomical views with smooth animated transitions
- Stats component for FPS monitoring in dev mode
- Placeholder capsule/sphere model as body stand-in

### Files changed
- **New**: `src/AnatomyViewer.tsx` - Complete 3D viewer component (250 lines)
- **Modified**: `src/App.tsx` - Added anatomy view and navigation
- **Modified**: `src/styles.css` - Added anatomy viewer styles (160 lines)
- **Modified**: `prd.json` - US-020 passes: true
- **Modified**: `package.json` - Added three, @react-three/fiber, @react-three/drei

### Learnings for future iterations
- **React Three Fiber pattern**: Use `<Canvas>` wrapper with inner components for Three.js objects
- **Camera animation**: Use requestAnimationFrame with lerp for smooth transitions
- **OrbitControls ref**: Access via ref to programmatically control camera position
- **Dev mode detection**: Use `window.location.hostname === 'localhost'` instead of `import.meta.env.DEV` to avoid Vite type issues
- **dpr setting**: Use `dpr={[1, 2]}` for retina display support while limiting max pixel ratio
- **Stats component**: From @react-three/drei, shows FPS/memory in dev mode

---

## 2026-01-20 - US-024

### What was implemented
- ModelLoader.tsx with comprehensive GLTF loading infrastructure
- useModelLoader hook: loadModel, cancelLoad, retryLoad, clearCache, getLoadState, isCached
- GLTFLoader configured with DRACOLoader for compressed models
- Loading progress tracking (0-100%) with abort controller support
- In-memory model cache (Map) to avoid reloading
- LoadingProgress component with progress bars, cancel/retry buttons
- Model component for easy rendering with position/rotation/scale
- useSystemLoader hook for lazy loading anatomical systems
- AnatomicalSystem type with 11 body systems defined

### Files changed
- **New**: `src/ModelLoader.tsx` - Complete model loading system (350 lines)
- **Modified**: `src/styles.css` - Loading progress overlay styles (120 lines)
- **Modified**: `prd.json` - US-024 passes: true

### Learnings for future iterations
- **DRACO decoder**: Use CDN path for decoder (gstatic.com/draco) or bundle locally
- **AbortController pattern**: Store in ref Map to cancel specific loads
- **Model cache**: Use Map<string, THREE.Group> at module level for persistence
- **Clone models**: Always clone from cache to allow multiple instances
- **Progress events**: GLTFLoader provides loaded/total bytes for progress calculation

---

## 2026-01-20 - US-025

### What was implemented
- LayerPanel.tsx component with full layer management UI
- 7 primary anatomical layers with sublayers (21 total)
- useLayerState hook for state management
- Visibility toggles, opacity sliders, solo mode
- 6 preset configurations (All Systems, Musculoskeletal, etc.)
- Expandable sublayer accordions
- localStorage persistence of layer state
- Integrated into AnatomyViewer with toggle button

### Files changed
- **New**: `src/LayerPanel.tsx` - Complete layer management (430 lines)
- **Modified**: `src/AnatomyViewer.tsx` - Integrated LayerPanel
- **Modified**: `src/styles.css` - Layer panel styles (250 lines)
- **Modified**: `prd.json` - US-025 passes: true

### Learnings for future iterations
- **Layer hierarchy**: Use dot notation (e.g., `cardiovascular.arteries`) for sublayer IDs
- **Solo mode pattern**: Store solo layer ID separately, apply in isVisible()
- **localStorage persistence**: Serialize Map to object for JSON.stringify
- **Preset system**: Define activeLayers array and filter visibility accordingly
- **Opacity inheritance**: Sublayer opacity should multiply with parent opacity

---

## 2026-01-20 - US-026

### What was implemented
- SelectionManager.tsx with comprehensive selection infrastructure
- useSelectionManager hook: select, addToSelection, toggleSelection, clearSelection
- RaycasterManager component for mouse picking using THREE.Raycaster
- OutlineEffect component for visual selection feedback
- SelectionInfo panel showing structure details
- Multi-select with Shift+click
- HIGHLIGHT_COLORS for hover/selected states
- useHighlightMaterials hook for material management
- StructureMetadata interface for FMA integration

### Files changed
- **New**: `src/SelectionManager.tsx` - Complete selection system (320 lines)
- **Modified**: `src/styles.css` - Selection info panel styles (130 lines)
- **Modified**: `prd.json` - US-026 passes: true

### Learnings for future iterations
- **Raycaster pattern**: Use useFrame to check hover state, event listener for clicks
- **Material swapping**: Store original materials in Map keyed by mesh.uuid
- **Multi-select**: Use Shift key event.shiftKey to toggle selection mode
- **Mesh registry**: Store Map<id, {mesh, metadata}> for structure lookup
- **Outline geometry**: Use THREE.EdgesGeometry(geometry, threshold) for edge detection

---

## Notes for Future Iterations

- The user is a medical student, so clinical accuracy matters
- Vision includes Complete Anatomy-level 3D interface
- All data must stay local - this is the core differentiator
- Educational only, never diagnostic
- Phase 3 is the largest phase - estimated 10-18GB of assets
- US-022 and US-023 require manual download of model/image datasets

